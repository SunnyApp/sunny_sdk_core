// DO NOT EDIT THIS FILE.  IT IS GENERATED AUTOMATICALLY AND YOUR CHANGES WILL BE OVERWRITTEN

import 'package:sunny_sdk_core/model_exports.dart';
import 'package:sunny_sdk_core/mverse.dart';

import 'diff_log_entry.dart'; // ignore: unusedimport, directives_ordering

class ChangeResult extends ChangeResultBase {
  ChangeResult(Map<String, dynamic> wrapped,
      {MSchemaRef mtype = ChangeResultRef, bool update = true})
      : super(wrapped, mtype: mtype, update: update);

  factory ChangeResult.fromJson(wrapped) => wrapped is ChangeResult
      ? wrapped
      : ChangeResult(wrapped as Map<String, dynamic>);

  ChangeResult.of({required bool changed, DiffLogEntry? diff})
      : super.of(
          changed: changed,
          diff: diff,
        );

  bool? get changed => _changed;
  set changed(bool? changed) {
    this._changed = changed;
    wrapped['changed'] = jsonLiteral(changed);
  }

  DiffLogEntry? get diff => _diff;
  set diff(DiffLogEntry? diff) {
    this._diff = diff;
    wrapped['diff'] = jsonLiteral(diff);
  }
}

abstract class ChangeResultBase extends MModel {
  ChangeResultBase(Map<String, dynamic> wrapped,
      {MSchemaRef mtype = ChangeResultRef, required bool update})
      : super(wrapped, mtype: mtype, update: false) {
    if (update == true) takeFromMap(wrapped, copyEntries: false);
  }

  ChangeResultBase.fromJson(wrapped)
      : this(wrapped as Map<String, dynamic>, update: true);
  ChangeResultBase.of({bool? changed, DiffLogEntry? diff})
      : super(<String, dynamic>{}, mtype: ChangeResultRef) {
    if (changed != null) this.changed = changed;
    if (diff != null) this.diff = diff;
  }

  bool? _changed;

  /// Property getter and setter for changed:
  bool? get changed;

  set changed(bool? changed);
  DiffLogEntry? _diff;

  /// Property getter and setter for diff:
  DiffLogEntry? get diff;
  set diff(DiffLogEntry? diff);

  @override
  String toString() => json.encode(wrapped).toString();
  dynamic toJson() => wrapped;

  @override
  operator [](key) {
    switch ("$key") {
      case "changed":
        return this.changed;
      case "diff":
        return this.diff;
      default:
        return wrapped[key];
    }
  }

  @override
  operator []=(String key, value) {
    switch (key) {
      case "changed":
        this.changed = value as bool;
        break;
      case "diff":
        this.diff = value as DiffLogEntry;
        break;
      default:
        wrapped[key] = value;
    }
  }

  @override
  void takeFrom(source) {
    if (source == null) return;
    if (source is Map<String, dynamic>) {
      takeFromMap(source, copyEntries: true);
    } else if (source is MModel) {
      takeFromMap(source.wrapped, copyEntries: true);
    } else {
      throw ("Can't take values from unknown type ${source.runtimeType}");
    }
  }

  @override
  void takeFromMap(Map<String, dynamic>? from, {bool copyEntries = true}) {
    if (from == null) return;

    super.takeFromMap(from, copyEntries: copyEntries);
    for (final entry in from.entries) {
      final key = entry.key;
      final value = entry.value;
      if (value == null) continue;
      switch (key) {
        case "changed":
          _changed = value as bool;
          break;
        case "diff":
          _diff = DiffLogEntry.fromJson(value);
          break;
        default:
          break;
      }
    }
  }

  @override
  ChangeResult clone() => ChangeResult.fromJson(deepCloneMap(wrapped));

  @override
  Set<String> get mfields => ChangeResultFields.values;
}

class ChangeResultFields {
  static const changed = "changed";
  static const diff = "diff";
  static const Set<String> values = {changed, diff};
}

class ChangeResultPaths {
  static const JsonPath<bool> changed =
      JsonPath.internal(["changed"], "/changed");
  static const JsonPath<DiffLogEntry> diff =
      JsonPath.internal(["diff"], "/diff");
  static final Set<JsonPath> values = {changed, diff};
}

const ChangeResultRef =
    MSchemaRef("mverse", "mthing", "changeResult", "0.0.1", "ephemeral");
