// DO NOT EDIT THIS FILE.  IT IS GENERATED AUTOMATICALLY AND YOUR CHANGES WILL BE OVERWRITTEN

import 'dart:convert';

import 'package:meta/meta.dart'; // ignore: unused_import, directives_ordering
import 'package:sunny_sdk_core/mverse.dart';
import 'package:sunny_dart/helpers/lists.dart';
import 'package:sunny_dart/helpers/maps.dart';
import 'package:sunny_dart/json.dart';

import 'change.dart';

class DiffLogEntry extends DiffLogEntryBase {
  ///
  DiffLogEntry(Map<String, dynamic> wrapped,
      {MSchemaRef mtype = DiffLogEntryRef, bool update = true})
      : super(wrapped, mtype: mtype, update: update);

  factory DiffLogEntry.fromJson(wrapped) => wrapped is DiffLogEntry
      ? wrapped
      : DiffLogEntry(wrapped as Map<String, dynamic>);

  DiffLogEntry.of({List<Change>? changes})
      : super.of(
          changes: changes,
        );

  List<Change>? get changes => _changes;
  set changes(List<Change>? changes) {
    this._changes = changes;
    wrapped['changes'] = jsonLiteral(changes);
  }
}

abstract class DiffLogEntryBase extends MModel {
  DiffLogEntryBase(Map<String, dynamic> wrapped,
      {MSchemaRef mtype = DiffLogEntryRef, required bool update})
      : super(wrapped, mtype: mtype, update: false) {
    if (update == true) takeFromMap(wrapped, copyEntries: false);
  }

  DiffLogEntryBase.fromJson(wrapped)
      : this(wrapped as Map<String, dynamic>, update: true);
  DiffLogEntryBase.of({List<Change>? changes})
      : super(<String, dynamic>{}, mtype: DiffLogEntryRef) {
    if (changes != null) this.changes = changes;
  }

  List<Change>? _changes;

  /// Property getter and setter for changes:
  List<Change>? get changes;
  set changes(List<Change>? changes);

  @override
  String toString() => json.encode(wrapped).toString();
  dynamic toJson() => wrapped;

  operator [](key) {
    switch ("$key") {
      case "changes":
        return this.changes;
      default:
        return wrapped[key];
    }
  }

  operator []=(String key, value) {
    switch (key) {
      case "changes":
        this.changes = value as List<Change>;
        break;
      default:
        wrapped[key] = value;
    }
  }

  @override
  void takeFrom(source) {
    if (source == null) return;
    if (source is Map<String, dynamic>) {
      takeFromMap(source, copyEntries: true);
    } else if (source is MModel) {
      takeFromMap(source.wrapped, copyEntries: true);
    } else {
      throw ("Can't take values from unknown type ${source.runtimeType}");
    }
  }

  void takeFromMap(Map<String, dynamic>? from, {bool copyEntries = true}) {
    if (from == null) return;

    super.takeFromMap(from, copyEntries: copyEntries);
    for (final entry in from.entries) {
      final key = entry.key;
      final value = entry.value;
      if (value == null) continue;
      switch (key) {
        case "changes":
          _changes = toList(value, (item) => Change.fromJson(item));
          break;
        default:
          break;
      }
    }
  }

  DiffLogEntry clone() => DiffLogEntry.fromJson(deepCloneMap(wrapped));

  @override
  Set<String> get mfields => DiffLogEntryFields.values;
}

class DiffLogEntryFields {
  static const changes = "changes";
  static const Set<String> values = {changes};
}

class DiffLogEntryPaths {
  static const JsonPath<List<Change>> changes =
      JsonPath.internal(["changes"], "/changes");
  static final Set<JsonPath> values = {changes};
}

const DiffLogEntryRef =
    MSchemaRef("mverse", "mthing", "diffLogEntry", "0.0.1", "ephemeral");
